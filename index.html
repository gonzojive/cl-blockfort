<html><head><title>Blockfort | DocDown document</title><style type='text/css'>a {
  text-decoration: none;
  }
a:hover {
  text-decoration: underline;
  }
pre {
  background-color: #ddeeff;
  border: 1px solid #aaaaff;
  padding: .5em;
  margin-left: 2em;
  }
blockquote {
  padding: 0 .5em;
  margin-left: 2em;
  font-style: italic;
  }
.symdoc {
  margin-left: 3em;
  }
.asdf {
  float: right;
  clear: right;
  margin: 1em .7em;
  width: 18em;
  background-color: #ddeeff;
  border: 1px solid #aaaaff;
  }
.asdf p {
  margin: .3em 0;
  }
.asdf small {
  font-size: 80%;
  }
.asdf table {
  font-size: 80%;
  }
.asdf table td {
  vertical-align: text-top;
  }
</style></head><body><div class='asdf'><div><strong>cl-blockfort</strong><small>   [ASDF system]</small></div><p><em>An ACID-compliant, persistent, and eventually distributed heap.</em></p><table><tr><td><strong>Version:</strong></td><td>0.2.0</td></tr><tr><td><strong>License:</strong></td><td>LGPL</td></tr><tr><td><strong>Website:</strong></td><td><a href='http://github.com/gonzojive/cl-blockfort'>on github.com</a></td></tr><tr><td><strong>Author:</strong></td><td>Red Daly &lt;reddaly at gmail&gt;</td></tr><tr><td><strong>Dependencies:</strong></td><td>alexandria, anaphora, bordeaux-threads, trivial-garbage, usocket</td></tr></table></div><h1>Blockfort</h1><a name='index'></a><h4>Blockfort: an <a href="#acid">ACID</a>-compliant transactional database engine</h4><p>Blockfort is a low-level, distributed transactional data store programmed in Common Lisp and intended for use by more abstract database systems. </p><p>There are many forms of databases, from pointer-based object databases to simple B-Tree stores like Berekely DB to monstrous black boxes like Oracle's products.  Blockfort attempts to support a wide range of these high-level database abstractions and provide all the necessary primitives. </p><p>Importantly, Blockfort is a distributed database system that is intended to scale well to many database nodes.  Of course, blockfort supports single-node operation, but the ability to scale a system is important and so Blockfort acknowledges a possible distributed nature and provides the appropriate primitives for high-level paradigms to operate. </p><p>All the code is maintained in a git repository.  To obtain the library, use the following command: </p><pre><code>git clone git://github.com/gonzojive/cl-blockfort.git </code></pre><h2>Contents</h2><ol><li><a href='#guide'>User Guide</a></li><ol><li><a href='#download'>Download and Installation</a></li></ol><li><a href='#concepts'>Concepts</a></li><ol><li><a href='#acid'>ACID</a></li><li><a href='#architecture'>System Architecture</a></li><ol><li><a href='#server'>Servers</a></li><li><a href='#store'>Stores</a></li><li><a href='#transactions'>Transactions</a></li><li><a href='#logs'>Logging</a></li></ol></ol><li><a href='#logging'>Undo/Redo Logging</a></li><ol><li><a href='#logging-rule'>Logging Rule</a></li><li><a href='#logging-transactions'>Logging transactions</a></li><ol><li><a href='#log-begin-transaction'>log-begin-transaction</a></li><li><a href='#log-commit-transaction'>log-commit-transaction</a></li><li><a href='#log-modification'>log-modification</a></li></ol><li><a href='#logging-recovery'>Recovering a database from a log</a></li><ol><li><a href='#log-recover'>log-recover</a></li></ol><li><a href='#logging-implementation-protocol'>Implementation Protocol</a></li><ol><li><a href='#logging-implementation-protocol-methods'>Methods that a database must implement</a></li><ol><li><a href='#db-undo-modification'>db-undo-modification</a></li><li><a href='#db-redo-modification'>db-redo-modification</a></li><li><a href='#db-element-as-octets'>db-element-as-octets</a></li><li><a href='#db-element-from-octets'>db-element-from-octets</a></li><li><a href='#db-value-as-octets'>db-value-as-octets</a></li><li><a href='#db-value-from-octets'>db-value-from-octets</a></li></ol><li><a href='#logging-implementation-protocol-mle'>Log entries</a></li><ol><li><a href='#log-entry-database-element'>log-entry-database-element</a></li><li><a href='#log-entry-old-value'>log-entry-old-value</a></li><li><a href='#log-entry-new-value'>log-entry-new-value</a></li></ol></ol></ol></ol><h2>User Guide</h2><a name='guide'></a><h3>Download and Installation</h3><a name='download'></a><p>All the code is maintained in a git repository.  To obtain the library, use the following command: </p><pre><code>git clone git://github.com/gonzojive/cl-blockfort.git </code></pre><p>You can also browse the code at <a href="http://github.com/gonzojive/cl-blockfort">http://github.com/gonzojive/cl-blockfort</a>. </p><h2>Concepts</h2><a name='concepts'></a><h3>ACID</h3><a name='acid'></a><p>Blockfort guarantees that certain behaviors are ACID compliant in its own sense and allows applications that call into Blockfort to guarantee ACID compliance in a way that makes sense for the application.  ACID transactions guarantee the following properties: </p><ul><li><p><em>Atomicity</em> -- The transaction executes either all or none of its operations.</p></li><li><p><em>Consistency</em> -- The database is in a "consistent" state before and after the transaction executes. </p></li><li><p><em>Isolation</em> -- Concurrent transactions appear to be executing one after another, and they do not reflect intermediate changes made by each other. </p></li><li><p><em>Durability</em> -- After a transaction has successfully committed, the database will reflect its changes. </p></li></ul><p>Atomicity and Durability are almost exclusively the responsibility of Blockfort, while Isolation and Consistency rely on the interaction of the database client and Blockfort.  These interactions will become clearer later in this chapter. </p><h3>System Architecture</h3><a name='architecture'></a><p>To accomplish ACID compliance, Blockfort relies on two basic principles: <a href="#transactions">transaction logging</a> for <a href="#recovery">recovering</a> from failures, and a concurrency scheduler for dealing with concurrently-executing transactions.  How ACID compliance is achieved in light of the rather agnostic nature of Blockfort in regards to the higher-level structure of its data should become clear after reading about blocks, concurrency control, and the interface between the two in Blockfort. </p><p><img src="architecture.png" alt="System architecture diagram"></img> </p><p>The above diagram illustrates the basic architecture of a blockstore-based database system.  For each computer involved in conducting transactions on the database, there is a <a href="#server">server</a> object that </p><h4>Servers</h4><a name='server'></a><p>Servers are the nodes on a distributed database that communicate with each other to effect database transactions.  We will document this further as more becomes clear about how they work. </p><h4>Stores</h4><a name='store'></a><p>A store makes database changes materialize in a persistent way.  A store need not know how it communicates with other stores (e.g. over ethernet)--that is the responsibility of the server.  A store must manage the data in the database by making sense of <a href="#transactions">transactions</a> and their component actions. </p><h4>Transactions</h4><a name='transactions'></a><p>In Blockfort, a <em>transaction</em> is an protocol that wraps a set of <em>actions</em> and guarantees atomicity, consistency, isolation, and durability.  Many different types and subtypes of transactions exist, and Blockfort attempts to abstract transactions enough to support many of the different types of transactions without overgeneralization. </p><ul><li><p><em>Lock-based transactions</em>:  Nearly all concurrent database systems use locks to some degree to implement transactions, though how exactly the locking scheme works varies widely.  Two-phase locking (2PL) guarantees serializability of transactions by requiring that no lock may be acquired after a single lock has been released.  A tree protocol for locking requires far less contention for B-Trees by violating 2PL and allowing locks after unlocks.  In both of these cases, the locking scheme is pessimistic, acquiring locks as data is read and written, and releasing the locks either at the end of the transaction (2PL) or as nodes on the tree are traversed (tree protocol). </p></li><li><p><em>Optimistic transactions</em>:  Optimistic transactions assume that data accesses will not conflict and checks these assumptions by performing an atomic validation step during commit.  Specific mechanisms in this league include timestamp methods and validation methods.  In many implementations of optimistic transactions, locks are still necessary but only during the commit phase. </p></li></ul><p>The details of the <a href="#transaction-protocol">transaction protocol</a> are described later. </p><h4>Logging</h4><a name='logs'></a><p>Blockfort provides undo/redo logging to support recovery from database crashes and thus satisfy the durability criterion of <a href="#acid">ACID</a>.  A logging package provides the logging functionality in a highly modular way. </p><h2>Undo/Redo Logging</h2><a name='logging'></a><p>To ensure durability of transactions, Blockfort maintains a disk log that can recover the entire database using just the log files.  The log is a separate package, CL-TRANSACTION-LOG, from the rest of blockfort to maintain modularity.  It works with an abstract idea of a database and only requires that a few functions be implemented and conventions be followed in order to make a database fully recoverable from a crash. </p><h3>Logging Rule</h3><a name='logging-rule'></a><p>The log mechanism at the moment is an undo/redo log, which has the following logging rule: </p><blockquote><p> <strong>Logging Rule</strong>: Before modifying any database element X on disk  because of changes made by some transaction T, it is necessary that  the update record appear on the disk. </p></blockquote><p>In addition, Blockfort enforces a strict commit rule: </p><blockquote><p> <strong>Commit Rule</strong>: A commit record must be flushed to disk before the  user is informed that a transaction committed. </p></blockquote><p>The strict commit semantics are necessary for certain applications and not for others, but we employ it here.  They ensure that when a transaction commits, it will be recovered frm the log by a commit. </p><h3>Logging transactions</h3><a name='logging-transactions'></a><p>The most common actions performed on a log are actions that occur during database transactions.  The functions most important to this interaction are: </p><ol><li><a href="#log-begin-transaction">log-begin-transaction</a> -- begins a transaction </li><li><a href="#log-commit-transaction">log-commit-transaction</a> -- commits a transaction </li><li><a href="log-modification">log-modification</a> -- logs a modification to disk </li></ol><p>Note that for all of these functions, a transaction is assumed to be an integer. </p><h4></h4><div>[Generic Function]</div><div><strong>log-begin-transaction</strong>  <em>transaction-log transaction </em></div><div class='symdoc'><a name='log-begin-transaction'></a><p>Logs, but does not flush, the beginning of a transaction. </p></div><h4></h4><div>[Generic Function]</div><div><strong>log-commit-transaction</strong>  <em>transaction-log transaction </em></div><div class='symdoc'><a name='log-commit-transaction'></a><p>Logs, but does not flush, the commit of a transaction. </p></div><h4></h4><div>[Generic Function]</div><div><strong>log-modification</strong>  <em>transaction-log transaction database-element old-value new-value </em></div><div class='symdoc'><a name='log-modification'></a><p>Logs a modification to the database element. </p></div><h3>Recovering a database from a log</h3><a name='logging-recovery'></a><p>Recovering is easy! </p><p><a href="#log-recover">log-recover</a> recovers a database from a log file. </p><h4></h4><div>[Generic Function]</div><div><strong>log-recover</strong>  <em>transaction-log database </em></div><div class='symdoc'><a name='log-recover'></a><p>Recovers the log to the last consistent state. That is, it undoes all uncommited transactions and redoes all committed transactions. </p></div><h3>Implementation Protocol</h3><a name='logging-implementation-protocol'></a><p>The log of the system requires that a database system obey a minimal protocol in order to be recoverable.  A database must implement several methods in order to comply with the procol.  In addition, it must interact with the logger according to the protocol described so far (i.e. use the transaction methods appropriately). </p><h4>Methods that a database must implement</h4><a name='logging-implementation-protocol-methods'></a><p>The following methods are those that any database that wished to comply with the logging protocol must implement. </p><h5></h5><div>[Generic Function]</div><div><strong>db-undo-modification</strong>  <em>database transaction-log modfication-log-entry </em></div><div class='symdoc'><a name='db-undo-modification'></a><p>Undoes the modification to the database. </p></div><h5></h5><div>[Generic Function]</div><div><strong>db-redo-modification</strong>  <em>database transaction-log modfication-log-entry </em></div><div class='symdoc'><a name='db-redo-modification'></a><p>Redoes the modification to the database. </p></div><h5></h5><div>[Generic Function]</div><div><strong>db-element-as-octets</strong>  <em>database database-element </em></div><div class='symdoc'><a name='db-element-as-octets'></a><p>Returns the database element of the given database as a vector of bytes. </p></div><h5></h5><div>[Generic Function]</div><div><strong>db-element-from-octets</strong>  <em>database octets </em></div><div class='symdoc'><a name='db-element-from-octets'></a><p>Returns the database element of the given database from a vector of bytes. </p></div><h5></h5><div>[Generic Function]</div><div><strong>db-value-as-octets</strong>  <em>database value </em></div><div class='symdoc'><a name='db-value-as-octets'></a><p>This is called by the log manager when a MODIFICATION-LOG-ENTRY must be written to disk.  It is called with either the LOG-ENTRY-OLD-VALUE or LOG-ENTRY-NEW-VALUE of a MODIFICATION-LOG-ENTRY. </p></div><h5></h5><div>[Generic Function]</div><div><strong>db-value-from-octets</strong>  <em>database value </em></div><div class='symdoc'><a name='db-value-from-octets'></a><p>This is called by the log manager when a MODIFICATION-LOG-ENTRY must be read from disk.  It is called with either the LOG-ENTRY-OLD-VALUE or LOG-ENTRY-NEW-VALUE of a MODIFICATION-LOG-ENTRY. </p></div><h4>Log entries</h4><a name='logging-implementation-protocol-mle'></a><p>The non-drowsy reader will notice that the db-* functions take a modification-log-entry argument.  This is a instance of a log entry class that has the following important functions: </p><h5></h5><div>[Generic Function]</div><div><strong>log-entry-database-element</strong>  <em>object </em></div><div class='symdoc'><a name='log-entry-database-element'></a></div><h5></h5><div>[Generic Function]</div><div><strong>log-entry-old-value</strong>  <em>object </em></div><div class='symdoc'><a name='log-entry-old-value'></a></div><h5></h5><div>[Generic Function]</div><div><strong>log-entry-new-value</strong>  <em>object </em></div><div class='symdoc'><a name='log-entry-new-value'></a></div></body></html>